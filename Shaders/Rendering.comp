#version 450
#extension GL_GOOGLE_include_directive: enable
#define LOCAL_INVOCATION 8
layout(local_size_x = LOCAL_INVOCATION) in;
layout(local_size_y = LOCAL_INVOCATION) in;
layout(local_size_z = 1) in;

#include "./Partial/Mesh.comp"
#include "./Partial/Light.comp"
#include "./Partial/triangleIntersection.comp"
#include "./Partial/rayMarching.comp"

//meshes
layout(set = 0, binding = 0) buffer Mesh {
  MeshBufferData meshes[];
};

//lights
layout(set = 1, binding = 0) buffer Light {
  LightData lights[];
};

//render image
layout(set = 2, binding = 0) buffer RenderInfo {
  uint renderWidth;
  uint renderHeight;
};
layout(set = 2, binding = 1) buffer Render {
  vec4 pixels[];
};

MinDistanceResponse GetMinDistance(vec3 point) {
  MinDistanceResponse rtn = {MAX_DIST, 0};
  for (uint i = 0; i < meshes.length(); i++) {
    float dist = SphereDist(meshes[i].Center.xyz, meshes[i].Bounds, point);
    if (rtn.dist > dist) {
      rtn.dist = dist;
      rtn.meshIndex = i;
    }
  }
  return rtn;
}

void main() {
  uint index = (gl_GlobalInvocationID.y * renderWidth) + gl_GlobalInvocationID.x;

  if (index >= renderWidth * renderHeight)
    return;

  vec2 uv = ((vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y)) - .5 * vec2(renderWidth, renderHeight)) / renderHeight;
  vec3 rayOrigin = vec3(0, 0, 0);
  vec3 rayDirection = normalize(vec3(uv, 1.));

  MinDistanceResponse ray = RayMarch(rayOrigin, rayDirection);
  if (ray.dist <= SURF_DIST) {
    for (uint j = 0; j < meshes[ray.meshIndex].IndiciesSize; j+=3) {
      Index i0 = meshes[ray.meshIndex].Indices[j + 0];
      Index i1 = meshes[ray.meshIndex].Indices[j + 1];
      Index i2 = meshes[ray.meshIndex].Indices[j + 2];
      vec3 vertices[3];
      vertices[0] = meshes[ray.meshIndex].Vertices[i0.Vertex].xyz;
      vertices[1] = meshes[ray.meshIndex].Vertices[i1.Vertex].xyz;
      vertices[2] = meshes[ray.meshIndex].Vertices[i2.Vertex].xyz;
      vec3 normals[3];
      normals[0] = meshes[ray.meshIndex].Normals[i0.Normal].xyz;
      normals[1] = meshes[ray.meshIndex].Normals[i1.Normal].xyz;
      normals[2] = meshes[ray.meshIndex].Normals[i2.Normal].xyz;
      vec2 textures[3];
      textures[0] = meshes[ray.meshIndex].Textures[i0.Texture].xy;
      textures[1] = meshes[ray.meshIndex].Textures[i0.Texture].xy;
      textures[2] = meshes[ray.meshIndex].Textures[i0.Texture].xy;
      Intersection intersect = triangleIntersection(rayOrigin, rayDirection, vertices, normals, textures);
      if (intersect.IsIntersected) {
        vec3 N = (normals[0] + normals[1] + normals[2]) / 3.;
        vec3 L = lights[0].Position.xyz;
        vec3 IL = L - intersect.Point;
        float diffuse = dot(N, L);
        if (diffuse < 0)
          diffuse = 0;
        pixels[index] = vec4(diffuse, diffuse, diffuse, 1.);
        return;
      }
    }
  }
  
  pixels[index] = vec4(0., 0., 0., 1.);
}