#version 450
#extension GL_GOOGLE_include_directive: enable
#define LOCAL_INVOCATION 8
layout(local_size_x = LOCAL_INVOCATION) in;
layout(local_size_y = LOCAL_INVOCATION) in;
layout(local_size_z = 1) in;

#include "./Partial/Mesh.comp"

//meshes buffer
layout(set = 0, binding = 0) buffer Mesh {
  MeshData meshes[];
};

//render image buffers
layout(set = 1, binding = 0) buffer RenderInfo {
  uint renderWidth;
  uint renderHeight;
};
layout(set = 1, binding = 1) buffer Render {
  vec4 pixels[];
};

#define MAX_STEPS 100
#define MAX_DIST 100.
#define SURF_DIST .01

float GetMinDistance(vec3 point);

float RayMarch(vec3 rayOrigin, vec3 rayDirection) {
  float distanceFromOrigin = 0.;
  for (int i = 0; i < MAX_STEPS; i++) {
    vec3 rayLocation = rayOrigin + (distanceFromOrigin * rayDirection);
    float dist = GetMinDistance(rayLocation);
    distanceFromOrigin += dist;
    if (distanceFromOrigin < SURF_DIST || distanceFromOrigin > MAX_DIST)
      break;
  }
  return distanceFromOrigin;
}
float SphereDist(vec3 position, float radius, vec3 point) {
  return length(point - position) - radius;
}

float GetMinDistance(vec3 point) {
  return SphereDist(
    vec3(0, 1., 5.),
    2.,
    point
  );
}

bool triangleIntersection(vec3 rayOrigin, vec3 rayDirection, Vertex vertices[3]) {
  //ray origin
  vec3 orig = rayOrigin;
  
  //ray direction
  vec3 dir = rayDirection;

  //triangle points
  vec3 v0 = vertices[0].Position.xyz;
  vec3 v1 = vertices[1].Position.xyz;
  vec3 v2 = vertices[2].Position.xyz;
  
  //triangle normal
  vec3 N = ((vertices[0].Normal + vertices[1].Normal + vertices[2].Normal) / 3).xyz;
  
  //Get ray triangle point
  float D = dot(N, v0);
  float t = -(dot(N, orig) + D) / dot(N, dir);

  //ray is beind the triangle so return false
  if (t >= 0)
    return false;

  vec3 P = orig + t * dir;

  //Is point inside triangle?
  vec3 edge0 = v1 - v0;
  vec3 edge1 = v2 - v1;
  vec3 edge2 = v0 - v2;
  vec3 C0 = P - v0;
  vec3 C1 = P - v1;
  vec3 C2 = P - v2;
  
  if (dot(N, cross(edge0, C0)) <= 0)
    return false;

  if (dot(N, cross(edge1, C1)) <= 0)
    return false;

  if (dot(N, cross(edge2, C2)) <= 0)
    return false;

  return true;
}

void main() {
  uint index = (gl_GlobalInvocationID.y * renderWidth) + gl_GlobalInvocationID.x;

  if (index >= renderWidth * renderHeight)
    return;

  vec2 uv = ((vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y)) - .5 * vec2(renderWidth, renderHeight)) / renderHeight;
  vec3 rayOrigin = vec3(0, 0, 0);
  vec3 rayDirection = normalize(vec3(uv, 1.));

  //float d = RayMarch(rayOrigin, rayDirection);
  //d /= 5.;
  //vec3 col = vec3(d);

  float d = 1.;

  Vertex tri[3] = {
    {
      {0, 1, 3, 0},
      {0, 0, -1, 0}
    },
    {
      {1, 0, 3, 0},
      {0, 0, -1, 0}
    },
    {
      {-1, 0, 3, 0},
      {0, 0, -1, 0}
    }
  };
  bool intersect = triangleIntersection(rayOrigin, rayDirection, tri);
  if (intersect)
    d = 0.;

  pixels[index] = vec4(d, d, d, 1.);
}