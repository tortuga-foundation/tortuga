#version 450
#extension GL_GOOGLE_include_directive: enable
#define LOCAL_INVOCATION 8
layout(local_size_x = LOCAL_INVOCATION) in;
layout(local_size_y = LOCAL_INVOCATION) in;
layout(local_size_z = 1) in;

#include "./Partial/Mesh.comp"
#include "./Partial/triangleIntersection.comp"
#include "./Partial/rayMarching.comp"

//meshes buffer
layout(set = 0, binding = 0) buffer Mesh {
  MeshBufferData meshes[];
};

//render image buffers
layout(set = 1, binding = 0) buffer RenderInfo {
  uint renderWidth;
  uint renderHeight;
};
layout(set = 1, binding = 1) buffer Render {
  vec4 pixels[];
};

MinDistanceResponse GetMinDistance(vec3 point) {
  MinDistanceResponse rtn = {99999, 0};
  for (uint i = 0; i < 1; i++) {
    float dist = SphereDist(meshes[i].Center.xyz, meshes[i].Bounds, point);
    if (rtn.dist > dist) {
      rtn.dist = dist;
      rtn.meshIndex = i;
    }
  }
  return rtn;
}

void main() {
  uint index = (gl_GlobalInvocationID.y * renderWidth) + gl_GlobalInvocationID.x;

  if (index >= renderWidth * renderHeight)
    return;

  vec2 uv = ((vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y)) - .5 * vec2(renderWidth, renderHeight)) / renderHeight;
  vec3 rayOrigin = vec3(0, 0, 0);
  vec3 rayDirection = normalize(vec3(uv, 1.));

  MinDistanceResponse ray = RayMarch(rayOrigin, rayDirection);
  if (ray.dist <= SURF_DIST) {
    for (uint j = 0; j < 3; j+=3) {
      uint i0 = meshes[ray.meshIndex].Indicies[j + 0];
      uint i1 = meshes[ray.meshIndex].Indicies[j + 1];
      uint i2 = meshes[ray.meshIndex].Indicies[j + 2];
      Vertex vertices[3];
      vertices[0] = meshes[ray.meshIndex].Verticies[i0];
      vertices[1] = meshes[ray.meshIndex].Verticies[i1];
      vertices[2] = meshes[ray.meshIndex].Verticies[i2];
      bool intersect = triangleIntersection(rayOrigin, rayDirection, vertices);
      if (intersect) {
        pixels[index] = vec4(0., 0., 0., 1.);
        return;
      }
    }
  }
  
  pixels[index] = vec4(1., 1., 1., 1.);
}